import argparse
import json
import os
import pathlib
import re
import shutil
import subprocess
import zipfile
from tempfile import TemporaryDirectory
from typing import Final


def clone_repo(repo_url, tempdir, token=None):
    repo_name = repo_url.split('/')[-1].replace('.git', '')
    repo_dir = os.path.join(tempdir, repo_name)

    if token:
        if repo_url.startswith("https://"):
            repo_url = repo_url.replace("https://", f"https://{token}@")
        else:
            raise ValueError("Для использования токена необходим HTTPS URL репозитория.")

    print(f"Cloning repository from URL: {repo_url}")

    subprocess.run(['git', 'clone', repo_url, repo_dir], check=True)

    zip_file = shutil.make_archive(repo_name, 'zip', repo_dir)

    print(f"Repository archived as {zip_file}")


def extract_files_from_archive(archive_path, extract_to):
    """Извлекает файлы из ZIP-архива."""
    with zipfile.ZipFile(archive_path, 'r') as zip_ref:
        zip_ref.extractall(extract_to)


def find_regex_patterns_in_file(file_path):
    regex_patterns = []
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            matches = re.findall(r'(?<!\\)(?:\\\\)*(\'.*?\')', line) + re.findall(r'(?<!\\)(?:\\\\)*(\".*?\")', line)
            regex_patterns.extend([match.strip('\'"') for match in matches])
    return regex_patterns


def analyze_with_regexploit(regex_pattern):
    try:
        process = subprocess.Popen(['regexploit'], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE)
        stdout, stderr = process.communicate(input=regex_pattern.encode())
        return stdout.decode()
    except Exception as e:
        return f"Error running regexploit: {str(e)}"


def is_pattern_malicious(analysis_result):
    """Проверка на наличие признаков уязвимости в выводе regexploit."""
    return "Worst-case complexity" in analysis_result


def save_results_to_json(results, json_file):
    with open(json_file, 'w') as jf:
        json.dump(results, jf, indent=4)
    print(f"Results saved to {json_file}")
    print("=" * 44)
    print(results)


def main(repo_url=None, token=None, zip_file=None, json_file=None):
    vulnerabilities = []

    with TemporaryDirectory() as tmpdir:
        if zip_file:
            print(f"Extracting files from ZIP archive: {zip_file}")
            extract_files_from_archive(zip_file, tmpdir)
        else:
            print(f"Cloning repository from URL: {repo_url}")
            clone_repo(repo_url, tmpdir, token)

        for root, dirs, files in os.walk(tmpdir):
            for file in files:
                if file.endswith(('.py', '.js', '.yaml', '.json', '.java', '.php', '.rb', '.pl', '.pm', '.cs', '.sh',
                                  '.html', '.htm')):
                    file_path = os.path.join(root, file)
                    patterns = find_regex_patterns_in_file(file_path)

                    for pattern in patterns:
                        print(f"Found pattern: {pattern} in file {file_path}")
                        result = analyze_with_regexploit(pattern)

                        if is_pattern_malicious(result):
                            vulnerability_info = {
                                'file': file_path,
                                'pattern': pattern,
                                'analysis_result': result
                            }
                            vulnerabilities.append(vulnerability_info)
                            print(f"Pattern {pattern} is potentially malicious!\nAnalysis result:\n{result}\n")
                        else:
                            print(f"Pattern {pattern} is not considered malicious.\n")

    if vulnerabilities and json_file:
        save_results_to_json(vulnerabilities, json_file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Scan code for regex patterns and analyze for ReDoS vulnerabilities.')
    parser.add_argument('--repo_url', type=str, help='URL of the git repository.')
    parser.add_argument('--token', type=str, help='GitHub Personal Access Token for private repositories.')
    parser.add_argument('--zip_file', type=str, help='Path to the ZIP archive to scan.')
    parser.add_argument('--output', type=pathlib.Path, help='Path to save the analysis results in JSON format.')

    args = parser.parse_args()

    JSON_FILE: Final[pathlib.Path] = pathlib.Path(__file__).parent / args.output

    main(repo_url=args.repo_url, token=args.token, zip_file=args.zip_file, json_file=JSON_FILE)
