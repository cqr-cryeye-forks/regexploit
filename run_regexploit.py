import argparse
import json
import os
import pathlib
import re
import shutil
import subprocess
import time
import zipfile
from typing import Final, List


class RepositoryNotFoundError(ValueError):
    """Invalid link to GitHub repository"""
    pass


def copy_zip_to_directory(zip_file_path, target_directory):
    if not os.path.isfile(zip_file_path):
        raise FileNotFoundError(f"Файл {zip_file_path} не найден.")

    if not os.path.exists(target_directory):
        os.makedirs(target_directory)

    destination = os.path.join(target_directory, os.path.basename(zip_file_path))

    shutil.copy2(zip_file_path, destination)

    return destination


def get_repo_name(input_string: str) -> str:
    def remove_suffix(name: str) -> str:
        return re.sub(r'\.zip$', '', name)

    if '/' in input_string or '\\' in input_string:
        repo_name = os.path.basename(os.path.normpath(input_string))
    elif 'github.com' in input_string:
        match = re.search(r'github\.com[:/](.*?)(?:\.git|$)', input_string)
        if match:
            repo_name = os.path.basename(match.group(1))
        else:
            raise ValueError("Invalid link to GitHub repository")
    else:
        repo_name = input_string

    repo_name = remove_suffix(repo_name)

    return repo_name


def clone_repo(repo_url, dest_dir, token=None):
    repo_name = repo_url.split('/')[-1].replace('.git', '')
    repo_dir = os.path.join(dest_dir, repo_name)

    if token:
        if repo_url.startswith("https://"):
            repo_url = repo_url.replace("https://", f"https://{token}@")
        else:
            raise ValueError("To use the token, you need the HTTPS URL of the repository.")

    print(f"Cloning repository from URL: {repo_url}")
    try:
        subprocess.run(['git', 'clone', repo_url, repo_dir], check=True)
    except subprocess.CalledProcessError:
        raise RepositoryNotFoundError
    return repo_dir


def extract_archives_in(directory):
    for item in os.listdir(directory):
        item_path = os.path.join(directory, item)
        if zipfile.is_zipfile(item_path):
            print(f"Extracting archive: {item_path}")
            with zipfile.ZipFile(item_path, 'r') as zip_ref:
                zip_ref.extractall(directory)
            os.remove(item_path)


def load_gitignore(directory):
    gitignore_path = directory / '.gitignore'
    ignore_patterns = []
    if gitignore_path.exists():
        with open(gitignore_path, 'r') as file:
            ignore_patterns = [line.strip() for line in file if line.strip() and not line.startswith('#')]
    return ignore_patterns


def save_results_to_json(results, json_file):
    with open(json_file, 'w', encoding='utf-8') as jf:
        json.dump(results, jf, indent=4)
    print(f"Results saved to {json_file}")
    print("=" * 44)
    print(results)


def remove_all_files(directory):
    try:
        command = f'echo 12345678 | sudo -S rm -rf {directory}'
        subprocess.run(command, shell=True, check=True)
        print(f"All files removed from directory: {directory}")
    except subprocess.CalledProcessError as e:
        print(f"Error occurred while removing files: {e}")


def is_pattern_malicious(analysis_result):
    """Checking regexploit output for signs of vulnerability."""
    return "Worst-case complexity" in analysis_result


def analyze_file_with_regexploit(file_path):
    file_suffix = file_path.suffix.lower()
    full_path_to_regexploit_files: Final[pathlib.Path] = MAIN_DIR / "regexploit/bin/"
    if file_suffix == '.py':
        str_path_to_run = str(full_path_to_regexploit_files) + "regexploit-py"
    elif file_suffix in ['.js', '.ts']:
        str_path_to_run = str(full_path_to_regexploit_files) + "regexploit-js"
    elif file_suffix in ['.yaml', '.yml']:
        str_path_to_run = str(full_path_to_regexploit_files) + "regexploit-yaml"
    elif file_suffix == '.json':
        str_path_to_run = str(full_path_to_regexploit_files) + "regexploit-json"
    elif file_suffix == '.cs':
        str_path_to_run = str(full_path_to_regexploit_files) + "regexploit-csharp"
    else:
        return None
    command = [str_path_to_run, str(file_path)]
    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()
        return stdout.decode()
    except Exception as e:
        return f"Error running regexploit: {str(e)}"


def should_ignore(file_path, ignore_patterns, use_gitignore=False):
    if use_gitignore:
        for pattern in ignore_patterns:
            if file_path.match(pattern):
                return False

    if file_path.suffix not in FILE_SUFFIX_CHECKER:
        return False

    return True


def scan_files(directory, ignore_patterns: List[str], use_gitignore=False):
    vulnerabilities = []
    for root, dirs, files in os.walk(directory):
        dirs[:] = [d for d in dirs if d not in ['.git', '.idea', '__pycache__']]
        for file in files:
            file_path = pathlib.Path(os.path.join(root, file))

            if should_ignore(file_path, ignore_patterns, use_gitignore):
                print(f"Scanning file: {file_path}")
                result = analyze_file_with_regexploit(file_path)
                print(result)
                if result and "Vulnerable regex" in result:
                    file_path_relative = str(file_path).replace(f'{directory}', '')
                    line_number = int(result.split('#')[1].split('\n')[0])
                    vulnerability_pattern = result.split('Pattern: ')[1].split('\n')[0]

                    vulnerability_score = result.split('starriness=')[1].split(',')[0].strip()

                    redos_start = result.index('redos_sequence=') + len('redos_sequence=')
                    open_braces = 0
                    close_braces = 0
                    redos_end = redos_start

                    for i in range(redos_start, len(result)):
                        if result[i] == '{':
                            open_braces += 1
                        elif result[i] == '}':
                            close_braces += 1
                        if open_braces > 0 and open_braces == close_braces:
                            redos_end = i + 1
                            break

                    redos_sequence = result[redos_start:redos_end]

                    repeated_character = result.split('repeated_character=')[1].split(']')[0] + ']'
                    sample_input = result.split('Example: ')[1].strip()

                    vulnerability_info = {
                        "file": file_path_relative,
                        "line": line_number,
                        "vulnerability_pattern": vulnerability_pattern,
                        "details": {
                            "vulnerability_score": int(vulnerability_score),
                            "redos_sequence": redos_sequence,
                            "repeated_character": repeated_character,
                            "sample_input": sample_input
                        }
                    }
                    vulnerabilities.append(vulnerability_info)

    return vulnerabilities


def check_name(repo_url=None, zip_file_name=None):
    if repo_url:
        get_name_from = str(repo_url)
    elif zip_file_name:
        get_name_from = str(zip_file_name)
    else:
        raise 'Use any argument: "--repo-url" [GIT_REPOSITORY] or "--input-zip" [ARCHIVE.ZIP]'

    repo_name = get_repo_name(get_name_from)
    return repo_name


def prepare_repository(repo_url=None, zip_file_name=None, token=None):
    repo_name = check_name(repo_url=repo_url, zip_file_name=zip_file_name)
    directory: Final[pathlib.Path] = MAIN_DIR / repo_name
    directory.mkdir(parents=True, exist_ok=True)

    if repo_url:
        print(f"Directory {directory} is empty. Cloning repository...")
        try:
            clone_repo(repo_url, directory, token)
        except RepositoryNotFoundError:
            remove_all_files(directory)
            return
    elif zip_file_name:
        zip_file_path = directory / zip_file_name
        copy_zip_to_directory(zip_file_path, directory)
    else:
        print(f"Directory {directory} is empty.")

    return directory


def process_repository(directory, use_gitignore=False):
    extract_archives_in(directory)

    ignore_patterns = []
    if use_gitignore:
        ignore_patterns = load_gitignore(directory)

    vulnerabilities = scan_files(directory, ignore_patterns, use_gitignore)

    remove_all_files(directory)

    if not vulnerabilities:
        vulnerabilities = {"Empty": "No vulnerable patterns found"}

    return vulnerabilities


def main(repo_url=None, zip_file_name=None, json_file=None, use_gitignore=None):
    directory = prepare_repository(repo_url=repo_url, zip_file_name=zip_file_name)
    if directory:
        vulnerabilities = process_repository(directory, use_gitignore=use_gitignore)
    else:
        vulnerabilities = {"Error": "Invalid link to GitHub repository, try to use git token with Registry"}
    save_results_to_json(vulnerabilities, json_file)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Scan repository or directory for files.')
    parser.add_argument('--repo-url', type=str, help='URL of the git repository.')
    # parser.add_argument('--token', type=str, help='GitHub Personal Access Token for private repositories.')
    parser.add_argument('--input-zip', type=pathlib.Path, help='Path to the input zip.')
    parser.add_argument('--output', type=pathlib.Path, help='Path to save the analysis results in JSON format.')
    parser.add_argument('--git-ignore', action='store_true', help='Use .gitignore to skip files and directories.')
    parser.add_argument('--suffix', default='all',
                        help="Use suffix for only this file type, choose any (1-7)"
                             "['.py', '.js', '.ts', '.cs', '.yaml', '.yml', '.json']"
                        )

    args = parser.parse_args()
    MAIN_DIR: Final[pathlib.Path] = pathlib.Path(__file__).parent
    JSON_FILE: Final[pathlib.Path] = MAIN_DIR / args.output
    FILE_SUFFIX_CHECKER = args.suffix
    if args.suffix == 'all':
        FILE_SUFFIX_CHECKER = [
            '.py',
            '.js',
            '.ts',
            '.cs',
            '.yaml',
            '.yml',
            '.json',
        ]
    time_start = time.time()
    main(repo_url=args.repo_url, zip_file_name=args.input_zip, json_file=JSON_FILE, use_gitignore=args.git_ignore)
    print(time.time() - time_start)
